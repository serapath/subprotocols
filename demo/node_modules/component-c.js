
const text = protocol('text')(onText)
const _class = protocol('.componentB')(onClass)

text('foobar')
_class(css.componentB)

// text('foo')(cp1(cp2(cp3))) // subscribe c1 to `foo` cp2 to cp1, cp3 to cp2
// text('foo')(cp1(cp4))(cp2)(cp3) // subscribe all to `foo`
// classes(text)


/*
const handleGet = ({ from, type, body }) => {
  if (type === 'get') return db.set('sub/sub/foo', 'bar')
}
const handleSet = ({ from, type, body }) => {
  if (type === 'set') return console.log(body.key, body.val)
}

const subhandleGet = ({ from, type, body }) => {
  if (type === 'get') return db.set('sub/foo', 'bar')
}
const subhandleSet = ({ from, type, body }) => {
  if (type === 'set') return console.log(body.key, body.val)
}

// ----------------------------------------------------------------------
const name = void 0 // => 'unknown_1'

const ledger = DB
const db = ledger()
const protocol = ledger(name, admin, trace)
// `trace` by default to use `id++`, but possible to pass in `new Error().stack`

const pipe = protocol()
peer(pipe(peer))
// OR
pipe(msg => console.log(msg))
for (const msg  in iterable) pipe(msg)

// pattern matching & restriction
// won't allow anything but `path: 'text'`
text0a = protocol({ path: 'text', type: 'set' }) // won't allow `type: 'on'`
text0b = protocol({ path: 'text', type: 'on'  }) // won't allow `type: 'set'`
text0c = protocol({ path: 'text', type: '*' })
text0c = protocol('text') // === { path: 'text', type: '*' }
text0c = protocol('text')

protocol([
  'text',

])
// `msg` currying of `{ path: 'text', type: 'set' }` from above
text0c('foo')
// `msg` currying of `{ path: 'text', type: 'on' }` from above
var fn = msg => console.log(msg) // `{ path: 'text', type: 'get' }`
text0c(fn) // { path: 'text', type: 'on', body: fn }
text0c((fn.off = 1, fn)) // { path: 'text', type: 'off', body: fn }
// `fn` => `address/path + pointer/id` + 
// THROWS if `body: fn` not given, because `'get'` requires body of type fn

// mid -> generated behind the scenes by `counter++`
// from -> generated behind the scenes by `new Error().stack` or `id++`
// ref -> ...
// path -> can be more than one segment, because `from` field already exists
// type -> `on` and `set` are supported, but `custom` (e.g. `once`) works fine
function admin ({ from, mid // generated behind the scenes
  path, ref, type, body
  path,      type, body
  // e.g. path = 'text'
  // e.g. type = 'set' || 'on'
}, postMessage) {
  // GOAL: if the associated `protocol()` or a `protocol.sub()`
  // 1. sends a message (`set`)
  // 2. requests a subscription (e.g. `on`)
  if (type == 'on' && path === 'text') {
    const oldValue = body // previous value posted via `postMessage`
    console.log('trace', from, mid, ref === 0)
    // @TODO: maybe `ref` could reference previous `postMessage()` calls?
    console.log(body === void 0)
    postMessage() // might PATCH a get and/or send INITIAL/CURRENT value
    // ...
  } else if (type == 'set' && path === 'text') {
    const newValue = body
    console.log('trace', from, mid, ref === 0)
    postMessage() // needs to trigger GETS
    // ...
  } else if (path === 'text') {
    console.log('trace', from, mid, ref === 0)
    // ...
  } else throw new Error('unexpected message type')
}
// ---- sub's

const name = void 0 // => 'unknown_1'
const subprotocol = protocol.sub(name, admin)

const subtext0 = subprotocol('text') // === { path: 'text', type: '*' }
subtext0a = subprotocol({ path: 'text', type: 'set' })
subtext0b = subprotocol({ path: 'text', type: 'on' })

subtext0a('foo') // `msg` currying of `{ path: 'text', type: 'set' }`
// `msg` currying of `{ path: 'text', type: 'on' }`
subtext0b(msg => console.log(msg))


const sub0     = subprotocol() // === { path: '*' }
// currying
sub0('foo') // THROWS, because of unknown `path`
const args = { path: 'text', type: 'set' }
sub0({ path: 'text', body: 'foo' }) // ok

// ----------------------------------------------------------------------

    db.on({ from: 'sub/sub/foo', type: 'get' }, handleGet)
    db.on({ from: 'sub/sub/foo', type: 'set' }, handleSet)
    db.on({ from: 'sub/foo', type: 'get' }    , handleGet)
    db.on({ from: 'sub/foo', type: 'set' }    , handleSet)
subdb.on({ from: 'sub/foo', type: 'get' }    , subhandleGet)
subdb.on({ from: 'sub/foo', type: 'set' }    , subhandleSet)
subdb.on({ from: 'foo', type: 'get' }        , subhandleGet)
subdb.on({ from: 'foo', type: 'set' }        , subhandleSet)

    db.on({ from: 'sub/sub/foo', type: 'get' }, handleGet)
    db.on({ from: 'sub/sub/foo', type: 'set' }, handleSet)
    db.on({ from: 'sub/foo', type: 'get' }    , handleGet)
    db.on({ from: 'sub/foo', type: 'set' }    , handleSet)
subdb.on({ from: 'sub/foo', type: 'get' }    , subhandleGet)
subdb.on({ from: 'sub/foo', type: 'set' }    , subhandleSet)
subdb.on({ from: 'foo', type: 'get' }        , subhandleGet)
subdb.on({ from: 'foo', type: 'set' }        , subhandleSet)
*/


// ------------ INTERCEPTION HOOKS ----------------
const STATE = {}
const handler = ({ type, body }) => {
  if (type === 'get') {
    return STATE[body]
  }
  if (type === 'set') {
    const { key, val } = body
    STATE[key] = val
  }
}
db.on(handler)



    db.onget('sub/sub/classes', next => next(value))
subdb.onget('sub/classes'    , next => next(value))

    db.onset('sub/sub/foo', val => console.log(val))
    db.onset('sub/sub/foo', val => console.log(val))
subdb.onset('sub/foo'    , val => console.log(val))
subdb.onset('sub/foo'    , val => console.log(val))

// ------------------------------------------------------------
const key = 'beep'
function main1 (db) {
  var val = sub(db)
  db.get(key)
}
function main2 (db) {
  var val = db.get(key)
  sub(db)
}
function sub (subdb) {
  subdb.get(key)
}
main1(db);/*VS.*/main2(db);

/*1*/var val =       db.get('variables')(val => console.log('variables', val))
/*2*/var val =    subdb.get('variables')(val => console.log('variables', val))
/*3*/var val = subsubdb.get('variables')(val => console.log('variables', val))

// -------------------------------------------------------
subsubdb.onget((key, resolve) => {
  if (key === 'variables')         resolve(value2)
})
subdb.onget((key, resolve)    => {
  if (typeof resolve !== 'function') set(key, resolve)
  if (key === 'variables')         resolve(value2)
  if (key === 'sub/variables')     resolve(value2)
})
db.onget((key, resolve)       => {
  if (typeof resolve !== 'function') set(key, resolve)
  if (key === 'variables')         resolve(value2)
  if (key === 'sub/variables')     resolve(value2)
  if (key === 'sub/sub/variables') resolve(value2)
})

/*1*/      db.set('foo', 'quux')
/*2*/   subdb.set('foo', 'baz')
/*3*/subsubdb.set('foo', 'bar')

subsubdb.onset((key, val) => {
  if (key === 'classes')           resolve(value1)
  if (key === 'variables')         resolve(value2)
})
subdb.onset((key, val)    => {
  if (typeof resolve !== 'function') set(key, resolve)
  if (key === 'classes')           resolve(value1)
  if (key === 'variables')         resolve(value2)
  if (key === 'sub/classes')       resolve(value1)
  if (key === 'sub/variables')     resolve(value2)
})
db.onset((key, val)       => {
  if (typeof resolve !== 'function') set(key, resolve)
  if (key === 'classes')           resolve(value1)
  if (key === 'variables')         resolve(value2)
  if (key === 'sub/classes')       resolve(value1)
  if (key === 'sub/variables')     resolve(value2)
  if (key === 'sub/sub/classes')   resolve(value1)
  if (key === 'sub/sub/variables') resolve(value2)
})

/*

    text1('foo')(cp1(cp2(cp3))) // subscribe c1 to `foo` cp2 to cp1, cp3 to cp2
    text1('foo')(cp1(cp4))(cp2)(cp3) // subscribe all to `foo`

*/